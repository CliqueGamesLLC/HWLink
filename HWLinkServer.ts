import * as hz from "horizon/core";
import { NetworkEvent, WorldInventory } from "horizon/core";

// ============================================================================
// HWLinkServer - Handles the server-side logic for Discord linking, including verification, persistent status, and optional reward distribution.
// Intended to be attached to a Server entity; be sure to set the World_Name and Secret_Key in the editor to match your Discord bot's configuration.
// This script works with a matching client UI (see HWLink.ts) via named NetEvents and payloads. Update event names/types on both sides if you make interface changes.
//
// All verification and reward granting logic runs here. The actual Discord code is generated by the bot on Discord‚Äîthe hash logic/codegen here must match for a given user/world/SecretKey combo or verification will always fail.
//
// Heads up: Only the constants below are illustrative. We use component properties at runtime (see propsDefinition/init) so design-time secrets stay safe!
//
const WORLD_NAME = "slaparena"; // example world name (lowercase recommended)
const PEPPER = "8d51ff7ae9ceee41b23e6b14913bd71e13dcc9a3477e34ae7dee25466de7b73b"; // example 64-char hex Secret_Key
const CODE_LENGTH = 6;
const CHARSET = '123456789ABCDEFGHJKMNPQRSTUVWXYZ';

const DISCORD_LINK_PPV_KEY = "DiscordLink:discordLinked"; // This key is stored per-player in persistent storage; set to 1 when linked successfully, 0 or missing otherwise.

// ============================================================================
// REWARD CONFIGURATION
// ============================================================================
// REWARD CONFIGURATION: All config lives here to minimize hot code edits. Use WorldInventory SKUs; toggle ENABLE_REWARDS. We support both durables and consumables.
// ============================================================================

// I keep reward items simple: a SKU and a quantity (for consumables).
type RewardItem = {
    sku: string;      // Paste the SKU from the Commerce panel
    quantity: number; // Consumables use this; Durables ignore it
};

// Flip this to true to enable automatic rewards after verification
const ENABLE_REWARDS = false;

// Put any number of items here from the Commerce panel. It will grant all of them on successful verify
const REWARD_ITEMS: RewardItem[] = [
    // Examples (replace with your SKUs):
    // { sku: "welcome_badge_sku", quantity: 1 },  // Durable (quantity ignored)
    // { sku: "gold_coins_sku", quantity: 100 },   // Consumable
    // { sku: "starter_pack_sku", quantity: 1 },   // Durable
    // { sku: "xp_boost_sku", quantity: 3 },       // Consumable
];

// Optional: I‚Äôll log this after rewards are granted (customize freely)
const REWARD_MESSAGE = "You've received verification rewards!";

// ============================================================================
// NETWORK EVENTS -- These must exactly match client-side names, types, and payloads. Edit both if you change ANYTHING here.
// ============================================================================

// Client ‚Üí Server: Ask me to verify a code
const VerifyCodeRequestEvent = new NetworkEvent<{
    code: string;
    username: string;
    playerId: number;
}>("HWLink:VerifyCodeRequest");

// Server ‚Üí Client: I send back the verification result
const VerifyCodeResponseEvent = new NetworkEvent<{
    success: boolean;
    message: string;
    alreadyLinked?: boolean;
    codeAlreadyUsed?: boolean;
}>("HWLink:VerifyCodeResponse");

// Client ‚Üí Server: Ask if this player is already linked
const CheckLinkStatusRequestEvent = new NetworkEvent<{
    playerId: number;
}>("HWLink:CheckLinkStatusRequest");

// Server ‚Üí Client: I report the player‚Äôs link status
const CheckLinkStatusResponseEvent = new NetworkEvent<{
    isLinked: boolean;
    playerId: number;
}>("HWLink:CheckLinkStatusResponse");

// Debug: Client ‚Üí Server: Reset my verification status
const DebugResetPlayerEvent = new NetworkEvent<{
    playerId: number;
}>("HWLink:DebugResetPlayer");

// Debug: Server ‚Üí Client: I confirm the debug action result
const DebugActionResponseEvent = new NetworkEvent<{
    success: boolean;
    message: string;
    playerId: number;
}>("HWLink:DebugActionResponse");

// ============================================================================
// SERVER-SIDE VERIFICATION MANAGER
// ============================================================================

// Main component holds all authoritative linking logic
class HWLinkServer extends hz.Component<typeof HWLinkServer> {
    // This structure matches what's expected from the Horizon Editor. Both World_Name and Secret_Key are required to match your Discord bot panel for generated codes to validate. Reward_Asset is optional‚Äîsee grantCustomReward for use.
    static propsDefinition = {
        World_Name: {
            type: hz.PropTypes.String,
            default: "",
            description: "Unique identifier for your world (lowercase letters only, must match Discord bot configuration)"
        },
        Secret_Key: {
            type: hz.PropTypes.String,
            default: "",
            description: "Secret_Key from your Discord bot setup (64-character hex string)"
        },
        Reward_Asset: {
            type: hz.PropTypes.Asset,
            description: "(Optional) An asset to spawn as a reward upon verification."
        }
    };

    // Main component lifecycle: startup checks props and wires up all required handlers for requests, status checks, and debug resets.
    start() {
        console.log("[HWLinkServer] Starting server-side verification manager...");
        
        // I sanity-check the required props so you get helpful errors
        if (!this.props.World_Name || this.props.World_Name.trim() === "") {
            console.error("[HWLinkServer] ERROR: Property 'World_Name' must be set in the editor.");
            console.error("[HWLinkServer] INSTRUCTIONS: Select this entity in the Hierarchy, find the 'Scripts' section in the Properties panel, and set the 'World_Name' field to your world's unique identifier (lowercase letters only).");
            return; // Stop initialization if required property is missing
        }
        
        if (!this.props.Secret_Key || this.props.Secret_Key.trim() === "") {
            console.error("[HWLinkServer] ERROR: Property 'Secret_Key' must be set in the editor.");
            console.error("[HWLinkServer] INSTRUCTIONS: Select this entity in the Hierarchy, find the 'Scripts' section in the Properties panel, and set the 'Secret_Key' field to your Discord bot's Secret_Key (64-character hex string from bot setup).");
            return; // Stop initialization if required property is missing
        }
        
        console.log(`[HWLinkServer] Configured for world: ${this.props.World_Name}`);
        
        // I listen for verification requests from clients
        this.connectNetworkBroadcastEvent(VerifyCodeRequestEvent, (data: { code: string; username: string; playerId: number; }) => {
            void this.handleVerifyRequest(data);
        });

        // I respond to link status checks on demand
        this.connectNetworkBroadcastEvent(CheckLinkStatusRequestEvent, (data: { playerId: number; }) => {
            void this.handleCheckLinkStatus(data);
        });

        // I expose a debug helper to reset player status
        this.connectNetworkBroadcastEvent(DebugResetPlayerEvent, (data: { playerId: number; }) => {
            void this.handleDebugResetPlayer(data);
        });

        console.log("[HWLinkServer] Ready to process verification requests");
    }

    // handleCheckLinkStatus: Accepts a link status check event. Looks up the player by id; returns true if verified, false otherwise (matches client-side state).
    private async handleCheckLinkStatus(
        data: { playerId: number }
    ): Promise<void> {
        const { playerId } = data;

        // I look up the player who asked
        const player = this.world.getPlayers().find(p => p.id === playerId);
        if (!player) {
            console.warn(`[HWLinkServer] Player ${playerId} not found`);
            return;
        }

        try {
            const linkValue = this.world.persistentStorage.getPlayerVariable<number>(player, DISCORD_LINK_PPV_KEY);
            const isLinked = typeof linkValue === "number" && linkValue !== 0;

            this.sendNetworkBroadcastEvent(
                CheckLinkStatusResponseEvent,
                { isLinked, playerId: player.id },
                [player]
            );
        } catch (error) {
            console.warn("[HWLinkServer] Failed to check link status:", error);
        }
    }

    // handleVerifyRequest: Core entry for player-originating requests. Validates a submitted code, writes status on success, and fires reward logic. Early exit if they're already verified.
    private async handleVerifyRequest(
        data: { code: string; username: string; playerId: number }
    ): Promise<void> {
        const { code, username, playerId } = data;

        // I identify the requesting player
        const player = this.world.getPlayers().find(p => p.id === playerId);
        if (!player) {
            console.warn(`[HWLinkServer] Player ${playerId} not found`);
            return;
        }

        console.log(`[HWLinkServer] Verification request from ${player.name.get()}: code=${code}, username=${username}`);

        // If they‚Äôre already linked, I short-circuit with a friendly message
        try {
            const linkValue = this.world.persistentStorage.getPlayerVariable<number>(player, DISCORD_LINK_PPV_KEY);
            if (typeof linkValue === "number" && linkValue !== 0) {
                console.log(`[HWLinkServer] Player ${username} already linked`);
                this.sendNetworkBroadcastEvent(
                    VerifyCodeResponseEvent,
                    {
                        success: false,
                        message: "You've already been verified!",
                        alreadyLinked: true,
                    },
                    [player]
                );
                return;
            }
        } catch (error) {
            console.warn("[HWLinkServer] Error checking link status:", error);
        }

        // I compute the expected code and compare
        const isValid = this.verifyCode(code, username);

        if (isValid) {
            console.log(`[HWLinkServer] ‚úÖ Code verified for ${username}`);

            // I persist the player's linked status
            try {
                this.world.persistentStorage.setPlayerVariable(player, DISCORD_LINK_PPV_KEY, 1);
            } catch (error) {
                console.warn("[HWLinkServer] Failed to save link status:", error);
            }

            // Grant rewards
            this.grantVerificationRewards(player, username);

            // Grant custom rewards (Assets, Logic, etc.)
            this.grantCustomReward(player);

            // I let the client know it worked
            this.sendNetworkBroadcastEvent(
                VerifyCodeResponseEvent,
                {
                    success: true,
                    message: "‚úÖ Verification successful! Welcome!",
                },
                [player]
            );
        } else {
            console.log(`[HWLinkServer] ‚ùå Invalid code for ${username}`);
            this.sendNetworkBroadcastEvent(
                VerifyCodeResponseEvent,
                {
                    success: false,
                    message: "‚ùå Invalid code! Please check and try again.",
                },
                [player]
            );
        }
    }

    // grantVerificationRewards: Called on successful link when ENABLE_REWARDS is true and any items are configured. Iterates all listed rewards and grants them using WorldInventory helper.
    private grantVerificationRewards(player: hz.Player, username: string): void {
        if (!ENABLE_REWARDS || REWARD_ITEMS.length === 0) {
            console.log("[HWLinkServer] Rewards disabled or no rewards configured.");
            return;
        }

        console.log(`[HWLinkServer] Granting ${REWARD_ITEMS.length} reward(s) to ${username}...`);

        // I iterate over your list and grant each item
        REWARD_ITEMS.forEach((reward, index) => {
            try {
                // Grant the item to the player
                WorldInventory.grantItemToPlayer(
                    player, 
                    reward.sku, 
                    reward.quantity
                );
                
                console.log(`[HWLinkServer] ‚úì Granted reward ${index + 1}/${REWARD_ITEMS.length}: ${reward.quantity}x "${reward.sku}"`);
            } catch (error) {
                console.error(`[HWLinkServer] ‚úó Failed to grant reward "${reward.sku}":`, error);
            }
        });

        // Optional log
        if (REWARD_MESSAGE) {
            console.log(`[HWLinkServer] ${REWARD_MESSAGE}`);
        }
    }

    // grantCustomReward: For extending with own game logic. Handles optional asset spawn (if provided in editor). Edit here to add more in-world effects (unlock doors, teleport, etc).
    private grantCustomReward(player: hz.Player): void {
        // Example 1: Spawn an asset (if one is dragged into the Reward_Asset slot)
        if (this.props.Reward_Asset) {
            console.log(`[HWLinkServer] Spawning reward asset for ${player.name.get()}`);
            
            // Calculate a position 1 meter in front of the player
            const playerPos = player.position.get();
            const playerFwd = player.forward.get();
            const spawnPos = playerPos.add(playerFwd.mul(1.0));
            
            // Spawn the asset
            this.world.spawnAsset(this.props.Reward_Asset, spawnPos, new hz.Quaternion(0, 0, 0, 1));
        }

        // Example 2: You could set a persistent variable to unlock a door elsewhere
        // this.world.persistentStorage.setPlayerVariable(player, "HasVipAccess", true);

        // Example 3: Teleport the player to a VIP area
        // player.position.set(new hz.Vec3(0, 100, 0));
    }

    // simpleHash: Basic DJB2-style hash (XOR mix). Used for deterministic, easy-to-debug code gen. Not cryptographically strong, but matching Discord bot for validation.
    private simpleHash(str: string): number {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            hash = (hash * 33) ^ str.charCodeAt(i);
        }
        return hash >>> 0; // Convert to unsigned 32-bit integer
    }

    // verifyCode: Given inputCode and username, rebuild the expected valid code for this world/user/key. Returns true on exact match (case-insensitive). The logic here MUST stay sync'd with any code-side Discord bot updater!
    private verifyCode(inputCode: string, username: string): boolean {
        // Build the same message your Discord bot uses
        const message = `${this.props.World_Name}|${username}|${this.props.Secret_Key}`;
        let hash = this.simpleHash(message);
        let expectedCode = '';
        
        // Map the hash into a non-ambiguous 6-char code
        for (let i = 0; i < CODE_LENGTH; i++) {
            expectedCode += CHARSET[hash % CHARSET.length];
            hash = Math.floor(hash / CHARSET.length);
        }
        
        // Compare codes (case-insensitive)
        return inputCode.toUpperCase() === expectedCode;
    }

    // handleDebugResetPlayer: Developer-only endpoint for resetting player status. Useful for QA or to fix test accounts stuck in linked state during dev.
    private async handleDebugResetPlayer(data: { playerId: number }): Promise<void> {
        const { playerId } = data;

        // I find the requesting player
        const player = this.world.getPlayers().find(p => p.id === playerId);
        if (!player) {
            console.warn(`[HWLinkServer] Debug: Player ${playerId} not found`);
            return;
        }

        const playerName = player.name.get();
        console.log(`[HWLinkServer] üîÑ DEBUG: Resetting verification status for ${playerName}`);

        try {
            // I reset the player's verification status to 0 (not linked)
            this.world.persistentStorage.setPlayerVariable(player, DISCORD_LINK_PPV_KEY, 0);

            this.sendNetworkBroadcastEvent(
                DebugActionResponseEvent,
                {
                    success: true,
                    message: `‚úÖ Your verification status has been reset!`,
                    playerId: player.id,
                },
                [player]
            );

            console.log(`[HWLinkServer] ‚úÖ Reset complete for ${playerName}`);
        } catch (error) {
            console.error("[HWLinkServer] Failed to reset player status:", error);
            this.sendNetworkBroadcastEvent(
                DebugActionResponseEvent,
                {
                    success: false,
                    message: `‚ùå Failed to reset status. Check console.`,
                    playerId: player.id,
                },
                [player]
            );
        }
    }
}

// Register component with the engine‚Äîattach via editor only on world/server entities with secure props configured. This should never run on the client side.
hz.Component.register(HWLinkServer);
